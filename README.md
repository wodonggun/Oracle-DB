# Oracle-DB

# 오라클 아키텍처

1. 오라클 클라이언트
2. 오라클 서버 프로세스
3. 오라클 백그라운드 프로세스(DBWR)

오라클 클라이언트(java,c, sql developer 등 )는 오라클서버의 프로세스에 연결된다.   
프로세스 뒤에 백그라운드 프로세스는 프로세서가 동작하기 위해 보조 역할을 함.  

클라이언트(클라이언트 프로세스) - 서버(서버 프로세스) - 디스크  


- `오라클 서버` : 버퍼 캐시에 데이터 유무에 따라 1~2ms, 캐시에 데이터가 없을때 디스크를 거치게 되면 40ms정도 속도 차이가 발생함.



# 블록

오라클은 `블록`단위로 데이터를 가지고 오고, 저장함.  


# SGA PGA 
```
기본적으로 프로세스는 메모리 공유가 불가능하다.  
(쓰레드끼리는 서로 메모리 공유가 가능함)  

버퍼캐시는 각 서버프로세스가 독립적으로 가지기에는 비효율적이므로, 하나의 버퍼캐시를 모든 프로세스가 공유함. 
```

- `PGA(Programing Global Area)` = 공유하지 않는 메모리 (각 서버프로세스 하나마다 독립적으로 가지고 있음)

- `SGA(System Global Area)` = 프로세스 끼리 공유하는 메모리 (A서버프로세스, B,C 모든 프로세스는 독립적으로 SGA를 가지고 있지만 서로 복사본 형태로 공유한다) 

SGA영역의 데이터 무결성을 위해 락(lock)을 걸고 사용함. 

  
 


# 세마포어

- 세마포어는 OS가 제공하는 자원관리를 하기 위한 장치
- 자원의 수에 비해 사용하고자 하는 프레소스의 수가 많을 경우 `순서대로 자원을 사용`할 수 있도록 제어 수행



# DBWR

- 데이터 변경, 버퍼 캐시 관리

- 버퍼캐시는 LRU(Least Recently Used) 알고리즘을 통해 관리됨. 


# 서버프로세스

- 서버 프로세스(오라클 서버)는 디스크에서 읽어오는 작업만 한다 -> 그럼 Update는 어떻게 진행할까?
- 서버프로세스는 디스크에서 데이터를 읽어와 캐쉬에 저장하고, 캐쉬에 저장된 데이터에 대해 수정을 진행한다.
- 캐시에 수정된 데이터는 디스크에 반영을 하지 않다가 `DBWR`이 캐시에 내용을 디스크에 저장함.

`서버프로세스는 크게 parse + execute + fetch`로 나누어짐.
1. parse = sql문법검사, 사용자 인증 및 권한 검사, 객체의 사용 가능 여부 검사.
2. execute = parse과정을 통해 `parse트리`로 만들어지고, parse 트리를 통해 원하는 데이터를 찾음 -> read, modify 진행.
3. fetch = 데이터를 사용자 클라이언트에게 전달.



# 백그라운드 프로세서

1. `DBWR` - 캐시 버퍼에 저장된 데이터를 디스크에 씀.

2. `LGWR` - 리두 로그 버퍼를 리두 로그 파일로 저장함.

3. `ARCH` - LGWR이 저장한 리두 로그 파일을 `아카이브 리두 로그 파일` 형태로 다시 저장함.  
(아카이브 리두 로그 파일 = 3개의 리두 로그파일)

4. `PMON` - 비정상적인 종료시에 메모리와 프로세스를 정리함 / 인스턴스 정보를 listener.ora에 기록함
5. `SMON` - 테이블 스페이스 안의 빈공간을 합침 / 처리 도중 종료된 트랜잭션 롤백 
6. `RECO` - 분산 트랜잭션을 관리 / 데이터베이스 1,2에 모두 변경하고 커밋을 진행할때 분산 트랜잭션 지원.

# 옵티마이저(파서)

- SQL을 분석하고, 실행을 어떻게 할건지 처리해주는 기능.
- 풀스캔할건지, 인덱스를 태울건지 결정해줌.

# 최적화

- A테이블에는 100만건의 데이터 ,B 테이블에는 100건의 데이터가 있을떄
1. A->B = 100만건의 데이터를 다 들고와서 100건의 데이터만 찾음.
2. B->A = 100건의 데이터를 들고와서 100만건의 데이터를 인덱싱해서 찾아감.

# RedoLog 리두로그

- 데이터의 변경 로그가 작성되어 있음.


# 인스턴스

- `인스턴스` - 백그라운드 프로세스 + 공유 메모리(서버프로세스가 접근하는 버퍼 캐시, 공유 풀)  
인스턴스가 생성되었다라는 말은 데이터베이스가 동작한다라고 봐도 됨. 
- RAC(Real Application Cluster ) - 한개의 데이터베이스에 여러개의 인스턴스를 띄움(하나가 죽더라도 동작은 계속함)



# 오라클 데이터 구조



```
논리구조(오라클)                    ------------------------------                               물리구조(하드웨어단)
 
테이블 스페이스(세그먼트 집합) = 여러개의 세그먼트를 가짐.                                      데이터파일 = 여러개의 블록   
세그먼트(인덱스, 테이블 등을 보관) = 여러개의 익스텐트를 가짐  
익스텐트(블록 집합) = 여러개의 블록(오라클단위)을 가짐       
블록(오라클 논리적 단위) 
```

# ROWID

- 데이터의 행 주소 ( 데이터 파일 번호, 블록 번호, 블록 내 행 번호 등 )

- ROWID 조회하기.
```
SELECT ROWID
      ,DBMS_ROWID.ROWID_RELATIVE_FNO(ROWID) file_no
      ,DBMS_ROWID.ROWID_BLOCK_NUMBER(ROWID) block_no
      ,DBMS_ROWID.ROWID_ROW_NUMBER(ROWID) row_no 
  FROM TEST;

```

# 프로세스 단에서 보는 데이터 흐름

- FullScan 할떄
A테이블을 읽어오려고 하는데 2개의 익스텐트(A,B)로 구성되어있다.  
버퍼캐시에는 A(1~6)중에서 A-1만 적재되어 있다? - Fullscan을 통해 A-2 ~ A-6, 그리고 B를 다 읽어와서 버퍼캐시에 올린다.  

- Index scan 할때  
인덱스가 저장되어있는 익스텐트로 이동하여서 ROWID정보를 확인함  
하지만 Fullscan과 같이 A,B 모든 데이터를 버퍼캐시에 올린다.(Fullscan은 모든 데이터 탐색을 통해 A,B익스텐트 위치를 찾는거임)  



# latch 래치

- lock과 같은 기능을 가진 경량화된 제어이다. 
- lock은 데이터베이스의 데이터 접근에 대한 제어이지만 `latch`는 `메모리접근(SGA)`에 대한 제어이다. 

# ACID

Atomicity


# Redo  Undo

- LGWR(프로세스)가 redo undo 작업을 수행함.


- 어떤 명렁을 했다. = Redo
- 어떤 명령을 해야 다시 돌아갈 수 있다. = Undo

- `롤포워드` - Redo로그를 통해 과거의 시점에서 미래의 시점으로 데이터를 변경해감.  
- `롤백` - Undo로그를 통해 과거의 시점으로 돌아감.  

- `리두 로그파일` - 일시적으로 redo 로그 저장  
- `아카이브 리두 로그파일`- 전체적인 redo 로그를 영구적으로 저장.(ARCH프로세스가 리두 로그파일을 -> 아카이브 리두 로그파일에 씀)  

커밋은 진행하였지만 DBWR프로세스가 디스크에 기록할 시간도 없이 장애가 나타났다면,  
Redo로그를 통해 데이터를 복구할 수 있다.(롤포워드)


```
redo 아키텍처 흐름


클라이언트(update 명령) -> 서버 프로세스가 버퍼캐시에 데이터를 읽어오고, 해당 버퍼캐시에 데이터 수정
-> 수정과 동시에 리두로그, 언두로그를 리두로그버퍼(SGA)에 기록함. -> COMMIT이 발생하면 서버 프로세스는 LGWR프로세스에게 
리두로그파일을 요청함 -> LGWR프로세스는 리두로그버퍼에 내용을 리두로그파일에 기록함.
-> 3개의 리두로그파일이 생성되면 ARCH프로세스는 아카이브 리두로그파일에 기록함. 
```



```
undo 아키텍처 흐름
        A                                                   B
09:00에 A테이블 전체 검색함.  
                                       09:01분에 A테이블의 1000번 데이터를 변경하고, Commit함.
09:05분에 A테이블의 1000번을 검색함 
(하지만 데이터는 09:00때 1000번 데이터를 읽어옴)
(undo로그를 통해 이전 데이터 복원하여 보여줌)


```


```
rollback 아키텍처 흐름


```

# 체크포인트
- 롤포워드 할때 너무 이전의 데이터와 리두로그를 가지고 있으면 시간이 오래걸리고, 데이터 보관해야할 양이 많아짐.
- 체크포인트를 통해 현재의 리두로그와 디스크를 동기화 시킴.

# ORA-1555

- d




